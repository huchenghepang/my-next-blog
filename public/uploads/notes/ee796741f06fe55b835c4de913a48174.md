**乐观锁（Optimistic Lock）** 是一种并发控制策略，它假设**多线程操作数据时冲突很少发生**，所以在读取数据时不加锁，只有在更新数据时才会检查是否被其他线程修改过。

> ✅ **核心思想**：**“先相信，后验证”** —— 我相信没人改过这数据，但提交时我会检查一下。

---

## 🌰 举个生活中的例子

想象你和朋友同时编辑一份共享文档：

- 你打开文档（读取数据）
- 朋友也打开同一份文档（并发读取）
- 你修改后保存（提交更新）
- 朋友稍后也修改并尝试保存

这时系统会检查：**“这份文档自从你打开后，有没有被别人改过？”**

- 如果没有 → 保存成功 ✅
- 如果有 → 提示“文档已被他人修改，请重新加载” ❌

这就是乐观锁的典型场景。

---

## 🔧 技术实现方式（以数据库为例）

最常见的实现方式是使用一个 **版本号字段（version）**。

### 1. 数据库表结构

```sql
CREATE TABLE `product` (
  `id` BIGINT PRIMARY KEY AUTO_INCREMENT,
  `name` VARCHAR(100),
  `price` DECIMAL(10,2),
  `version` INT DEFAULT 1  -- 版本号字段
);
```
### 2. 更新流程

假设你读取到的数据是：

```json
{
  "id": 1,
  "name": "iPhone",
  "price": 999.99,
  "version": 3
}
```
🔍 关键点：**同时判断 ID 和 version**

- 如果更新成功（影响行数 = 1）→ 说明没人动过数据，更新成功 ✅
- 如果更新失败（影响行数 = 0）→ 说明 version 已被别人改成了 4，你的 3 就失效了 ❌

此时系统应提示用户：“数据已被其他人修改，请刷新后再操作。”

---

## ✅ 乐观锁 vs 悲观锁

|对比项|乐观锁|悲观锁|
|---|---|---|
|假设|冲突很少发生|冲突经常发生|
|是否加锁|读时不加锁|读时就加锁（如`SELECT ... FOR UPDATE`）|
|性能|高（适合读多写少）|较低（阻塞其他操作）|
|实现方式|版本号、时间戳|数据库行锁、同步锁|
|适用场景|电商库存、文章编辑、配置管理|银行转账、强一致性场景|

---

## 💡 乐观锁适用场景

✅ 推荐使用乐观锁的场景：

- **读多写少**
- **并发冲突概率低**
- **如：商品信息编辑、文章发布、用户资料修改**

❌ 不适合的场景：

- 高并发频繁修改同一数据（比如秒杀库存扣减，需配合其他机制）

> ⚠️ 注意：单纯的乐观锁在极端高并发下可能重试多次才成功，需结合 Redis + Lua 或队列优化。

---

## 🛠️ MyBatis-Plus 中如何使用乐观锁？

### 步骤 1：添加 `version` 字段

```java
@Version
private Integer version;
```

### 步骤 2：配置插件（Spring Boot）

```java
@Bean
public MybatisPlusInterceptor mybatisPlusInterceptor() {
    MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
    // 添加乐观锁插件
    interceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor());
    return interceptor;
}
```

### 步骤 3：使用（自动生效）

```java
// 查询
Product product = productMapper.selectById(1);

// 修改
product.setPrice(1199.99);
productMapper.updateById(product); // MP 自动处理 version 比较和递增
```

---

## 📝 小结

|特点|说明|
|---|---|
|**不阻塞**|多人可以同时读取数据|
|**轻量级**|不依赖数据库锁，性能好|
|**最后防线**|提交时才检查冲突|
|**失败处理**|需要业务层处理“更新失败”的情况（提示或重试）|

---

✅ **一句话总结**：

> 乐观锁就像“文档协作编辑”，你不拦着别人看，但保存时要确认没人抢先改了。

如果你做的是管理系统、内容平台、电商后台，**乐观锁是非常推荐使用的并发控制手段**。